#include <iostream>
#include <string>
#include <cctype>
using namespace std;
class hall_of_knowledge
{
    int counter=0;
    int count=0;
    int check=0;
    string Q[14];
    char A[14];
    char input;
    public:
    void rabbit_hole()
        {
            count++;
            cout<<"\nObjective "<<count<<"."<<endl<<endl;
            switch (count)
            {
                case 1:
                        cout<<"In C++, single-line comments are written using //.Everything after // on that line is ignored by the compiler.They are useful for providing brief explanations about the code.\nEg:\n// This is a single-line commentint\nx = 10; // Initializing variable x\n";
                    break;
                case 2:
                          cout<<"A function declaration, also known as a function prototype, informs the compiler about the function's name, return type, and parameters before its actual definition.This is important in cases where the function definition appears later in the program.\n";
                    break;
                case 3:
                        cout<<"A local variable is declared inside a function and can only be accessed within that function.\nIt is created when the function starts and destroyed when the function ends.\nLocal variables cannot be accessed outside the function.\n";
                    break;
                case 4:
                          cout<<"C++ has a strict type system than C, preventing unintended type conversions that could lead to errors.Type checking ensures variables and expressions follow proper data type rules.\n\nint x = 10.5; // Compiler gives a warning or error due to implicit conversion from double to int\n";
                    break;
                case 5:
                          cout<<"A reference is an alias for an existing variable.\nIt must be initialized when declared and cannot be changed later.\nReferences are commonly used in function parameter passing to avoid copying large objects.\n\nEg:\nint a = 10;\nint &ref = a; // ref is another name for a\nref = 20; // Now, a is also 20\n";
                    break;
                case 6:
                          cout<<"When a function receives a parameter by value, it gets a copy of the argument, meaning changes inside the function do not affect the original variable.\n";
                    break;
                case 7:
                          cout<<"When a function receives a parameter by reference, it works with the original variable.Changes inside the function affect the original variable.\n";
                    break;
                case 8:
                          cout<<"A default argument is a value assigned to a function parameter that is used when no argument is provided during the function call.Default arguments are specified in the function declaration.\n"<<endl;
                    break;
            }
        }
    hall_of_knowledge()
    {
        //delete operator
        Q[0]="Which of the following is true about the delete operator?\nA) It is used to allocate memory dynamically\nB) It deallocates memory and sets the pointer to NULL automatically\nC) It deallocates memory but does not reset the pointer\nD) It can be used only for arrays\n";
        A[0]='C';
        //comments
        Q[1]="How are single-line comments written in C++?\nA) /* comment */\nB) # comment\nC) // comment\nD) ' comment";
        A[1]='C';
        //local variable
        Q[2]="Which statement about local variables in C++ is correct?\nA) They are accessible throughout the entire program\nB) They are created when a function starts and destroyed when it ends\nC) They must be declared outside any function\nD) They can be accessed by all functions in the program";
        A[2]='B';
        //function overloading
        Q[3]="cout << add(3.5, 2);\nWhich of the following overloaded function prototypes can handle this call?\nA) int add(int a, int b, int c);\nB) double add(double x, double y);\nC) double add(int p, double q);\nD) Compilation error\n";
        A[3]='D';
        //function overloading
        Q[4]="What determines which overloaded function is called?\nA) The function's return type\nB) The number and type of arguments passed in the function call\nC) The order in which the functions are defined\nD) The functions access specifier (public, private, protected)\n";
        A[4]='B';
        //fn prototype
        Q[5]="What is the purpose of a function prototype in C++?\nA) To define the function before its usage\nB) To declare the function before its actual definition\nC) To store the functions return value\nD) To execute the function automatically";
        A[5]='B';
        //new operator
        Q[6]="What does the new operator do in C++?\nA) Declares a pointer variable\nB) Allocates memory dynamically and returns its address\nC) Initializes a pointer to NULL\nD) Frees dynamically allocated memory\n";
        A[6]='B';
        //new operator
        Q[7]=" What happens if new fails to allocate memory?\nA) It returns NULL\nB) It throws a bad_alloc exception\nC) It terminates the program immediately\nD) The compiler generates a warning\n";
        A[7]='B';
        //reference
        Q[8]="What happens when a function parameter is passed by reference?\nA) The function gets a copy of the argument\nB) The original variable remains unchanged\nC) Changes inside the function affect the original variable\nD) The function does not receive any argument";
        A[8]='C';
        //operators
        Q[9]="What will be the output of the following code?\nint a = 5, b = 10;\ncout << (a > 2 && b < 20);\nA) 0\nB) 1\nC) true\nD) false\n";
        A[9]='B';
        //inline functuion
        Q[10]=" Consider the following code snippet:\ninline int square(int x)\n{ return x * x; }\nint main()\n{\ncout << square(5 + 2);\n}\nWhat will be the output?\nA) 49\nB) 25\nC) Compilation error\nD) Undefined behavior\n";
        A[10]='A';
        //inline function
        Q[11]="Which of the following statements is true about inline functions?\nA) Inline functions are always expanded at runtime\nB) Inline functions allow execution of multiple statements inside loops efficiently\nC) Inline functions execute faster because their address is precomputed\nD) Inline functions are expanded at compile time, reducing function call overhead\n";
        A[11]='D';
        //inline function
        Q[12]="When should you avoid using inline functions?\nA) For very small functions\nB) For large, complex functions\nC) When reducing memory footprint is important\nD) Both B and C\n";
        A[12]='D';
        //default argument 
        Q[13]="What is a default argument in C++?\nA) A value automatically assigned to a function parameter when no argument is passed\nB) The first argument in every function call\nC) A mandatory argument required in every function\nD) A parameter that can never be changed";
        A[13]='A';
    }
    void open_door()
    {
        counter++;
        display_theory();
    }
    void display_theory()
        {
        cout<<"\nDoor "<<counter<<" has been opened."<<endl<<endl;
        switch (counter)
        {
            case 1:
                cout<<"Overloading refers to the use of the same thing for different purposes.\nC++ also permits overloading of functions.\nThis means that we can use the same function name to create functions that perform a variety of different tasks.\nThis is known as function polymorphism in OOP.\nUsing the concept of function overloading; we can design a family of functions with one function name but with different argument lists.\nThe function would perform different operations depending on the argument list in the function call.\nThe correct function to be invoked is determined by checking the number and type of the arguments but not on the function type.\nFor example, an overloaded add() function handles different types of data as shown below:\nint add(int a, int b, int c);        // prototype 1\ndouble add(double x, double y);      // prototype 2\ndouble add(int p, double q);         // prototype 3\n\ncout << add(5, 10, 15);              // uses prototype 1\ncout << add(12.5, 7.5);              // uses prototype 2\ncout << add(15, 10.0);               // uses prototype 3\n";
                break;
            case 2:
                cout<<"An object can be created by using new, and destroyed by using delete, as and when required. A data object created inside a block with new, will remain in existence until it is explicitly destroyed by using delete. Thus, the lifetime of an object is directly under our control and is unrelated to the block structure of the program.The new operator can be used to create objects of any type. It takes the following general form:\n\npointer-variable = new data-type;\n\nHere, pointer-variable is a pointer of type data-type. The new operator allocates sufficient memory to hold a data object of type data-type and returns the address of the object. The data-type may be any valid data type. The pointer-variable holds the address of the memory space allocated. Examples:\n\np = new int;\nq = new float;\n\nWhen a data object is no longer needed, it is destroyed to release the memory space for reuse. The general form of its use is:\n\ndelete pointer-variable;\n\nThe pointer-variable is the pointer that points to a data object created with new. Examples:\n\ndelete p;\ndelete q;\n";
                break;
            case 3:
                cout<<"One of the objectives of using functions in a program is to save some memory space, which becomes appreciable when a function is likely to be called many times. However, every time a function is called, it takes a lot of extra time in executing a series of instructions for tasks such as jumping to the function, saving registers, pushing arguments into the stack, and returning to the calling function. When a function is small, a substantial percentage of execution time may be spent in such overheads.\nC++ has a different solution to this problem. To eliminate the cost of calls to small functions, C++ proposes a new feature called inline function. An inline function is a function that is expanded in line when it is invoked. That is, the compiler replaces the function call with the corresponding function code (something similar to macros expansion).\nIt is easy to make a function inline. All we need to do is to prefix the keyword inline to the function definition. All inline functions must be defined before they are called.\nEg:\n\n\tinline double cube(double a)\n\t{\n\treturn (a * a * a);\n\t}\n\tc = cube(3.0);\n\td = cube(2.5 + 1.5);\n\nThe speed benefits of inline functions diminish as the function grows in size. At some point, the overhead of the function call becomes small compared to the execution of the function, and the benefits of inline functions may be lost. In such cases, the use of normal functions will be more meaningful.\n";
                break;
            case 4:
                cout<<"Operators are symbols that perform operations on variables and values.\nTypes of operators:\n\nArithmetic (+, -, *, /, %)\nRelational (==, !=, <, >, <=, >=)\nLogical (&&, ||, !)\nBitwise (&, |, ^, ~, <<, >>)\nAssignment (=, +=, -=, *=, /=, %=)\n";
                break;
            case 5:
                cout<<"Type casting operator\n";
                break;
        }
    }
    void read()
    {
        cout<<"Answer (A/B/C/D): ";
        cin>>input;
        input=toupper(input);
    }
    void question()
    {
        for (int i=0;i<14;i++)
        {
            cout<<"Question: "<<i+1 <<endl<<Q[i]<<endl;
            do
            {
                read();
                if (input!='A' && input!='B' && input!='C' && input!='D')
                {
                    cout <<"Invalid answer. Please choose A, B, C, or D."<<endl;
                }
            } while (input!='A' && input!='B' && input!='C' && input!='D');
            cout<<endl;
            counter++;
        }
    }
    ~hall_of_knowledge()
    { }
};
class Animal
{
public:
    void owl(int ind) 
    {
        string messages[] = 
        {
            "Owl: 'You know my dear Alice, the scope of a variable extends from the point of its declaration till the end of the block containing the declaration. A variable declared inside a block is said to be local to that block.You should remember that a declaration of the same variable in an outer block, and therefore, each declaration of a variable causes it to refer to a different data object.'", 
            "Owl: 'C++ allows the common functions to be made friendly with both the classes, thereby allowing the function to have access to the private data of these classes. Such a function need not be a member of any of these classes. Also, the function declaration should be preceded by the keyword 'friend'.\nFish: 'A friend function has special characteristics:\n1] It is not in scope of the class to ehich it has been declared as friend\n2] Since it is not in the scope of the class, it cannot be called using the object of that class.\n3] It can be invoked like a normal function without the help of any object.\n4] Unlike member functions, it cannot access the member names directly and has to use an object name and dot membership operator with each member name.\n5] It can be declared either in the public or the private part of a class without affecting its meaning.\n6] Usually, it has the objects as arguments.'\nCat: 'You can declare all the member functions of one class as the friend functions of another class. In such cases, the class is called a friend class.'\n\n Owl: 'Although it is normal practice to place all the data items in a private section and all the functions in public, some situations may require certain functions to be hidden from outside calls.'", 
            "Owl: 'The deferencing operator ->* is used to access a member when we use pointers to both the objects and the member. The deferencing operator is used when the object itself is used with the member pointer.\n\n'",
            "Owl: 'Operator overloading is done with the help of a special function, called operator function, which describes the special task to an operator. There are certain restrictions and limitations in overloading operators.'",
            "Owl: 'The derived class inherits some or all of the properties of the base class. A derived class with only one base class is called single inheritance. A class can inherit properties from more than one class which is known as multiple inheritance.'",
            "Owl: 'In multiple inheritance, the base classes are constructed in the order in which they appear in the declaration of the derived class. In multilevel inheritance, the constructors are executed in the order of inheritance. A class can contain objects of other classes. This is known as containership or nesting.\n\n'",
             "Owl: 'That means, there is no ambiguity at the compile time about which a function is to be linked to a particular function's call. This mechanism is called early binding or static binding or static linking  Compile time polymorphism is achieved in two ways: function overloading and operator overloading.'"
        };
        cout << messages[ind % 7] << "\n";
    }
    void fish(int ind) 
    {
        string messages[] =
        {
            "Fish: 'Yeah Alice! C++ resolves this problem by introducing a new operator :: called the scope resolution operator. This operator allows access to the global version of a variable.\n\n'", 
            "Fish: 'We can place these functions in the private section. A private function can only be called by another function that is a member of its class. Even an object cannot invoke a private function using dot operator.'", 
            "Fish: 'C++ provides a special member function called the constructor which enables an object to initialize itself when it is created. This is known as automatic initialization of objects. A constructor has the same name as that of the class. It is normally used to initialize variables and to allocate memory. They can also be overloaded.'", 
            "Fish: 'Operator functions must either be member functions (nonstatic) or friend functions. The overloading operator must have at least one operand that is of user defined type.'",
            "Fish: 'A class can be derived from another derived class which is known as multilevel inheritance. When the properties of one class are inherited by more than one class, it is called hierarchical inheritance.'",
            "Fish: 'A pointer can point to an object created by a class. Object pointers are useful in creating objects at run time. You can also use an object pointer to access the public members of an object. You can refer to the member functions in two ways, one by using the dot operator and the object and another using the arrow operator and the object pointer.'",
            "Fish: 'Run time polymorphism defers the linking of a function call to a particular class much later, that is, at run time. Thus, it is not known which function will be invoked till an object actually makes the function call during the program's execution. This process is referred as late or dynamic binding.\n\n"
        };
        cout << messages[ind % 7] << "\n";
    }
    void cat(int ind) 
    {
        string messages[] = 
        {
            "Cat: 'Also! member functions can be defined in two places: outside the class definition or inside the class definition. An important difference between a member functionand a ormal function is that a member function incorporates a membership 'identity label' in the header. This 'label' tells the compiler which class the function belongs to.'", 
            "Cat: 'Public data is accessible from anywhere -  inside the class, in derived (child) classes, and outside the class. It is often used for functions that provide an interface to interact with private or protected data.'", 
            "Cat: 'When an object is created and initialized at the same time, a copy constructor gets called. We may make an object const if it does not modify any of  its data values. C++ also provides another member function called the destructor that destroys the objects when they are no longer required.\n\n", 
            "Cat: 'The compiler does not support automatic type conversions for the user defined data types. We can use casting operator functions to achieve this.'",
            "Cat: 'A private member of a class cannot be inherited either in public mode or private mode. A protected member inherited in public mode becomes protected, whereas inherited in private mode becomes private in the derived class.'",
            "Cat: 'Oh yes!\nx.getdata(100,75);\nx.show;\nis equivalent to\nptr->getdata(100,75);\nptr->show();\nYou can also create objects using pointers and new operator like so:\nitem *ptr=new item;\nThis statement allocates enough memory for the data members in the object structure and assigns the operator of the memory space to ptr.\n'",
            "Cat: 'I hope this talk with us was rewarding for you dearie!'"
        };
        cout << messages[ind % 7] << "\n";
    }
    void mole(int ind) 
    {
        string messages[] = 
        {
            "Mole: 'Yes! when a function is defined inside a class, it is treated as an inline function. Therefore, all the restrictions are limitations that apply to an inline function are also applicable here. Normally, only small functions are defined inside the class definition.'", 
            "Mole: 'Protected data is accessible inside the class and by derived (child) classes. It is not accessible outside the class (i.e., from main() or non-member functions) and is used when you want child classes to have access, but not external users.\n\n'", 
            "Mole: 'Operator overloading is one of the important features of C++ language that enhances its exhaustibility. Using overloading feature we can add two user defined data types such as objects, with the same syntax, just as basic data types.'", 
            "Mole: 'The casting operator function should satisfy the following conditions:\n 1] It must be a class member\n 2] It must not specify a return type\n 3] It must not have any arguments\n\n'",
            "Mole: 'A public member inherited in public mode becomes public, whereas inherited in private mode becomes private in the derived class. The friend functions and the member functions of a friend class can directly access the private and protected data. The member functions of a derived class can directly access only the protected and public data.'",
            "Mole: 'C++ uses a unique keyword called this to represent an object that invokes a member function. this is a pointer that points to the object for which this function was called. This unique pointer is automatically passed to a member function when it is called. The pointer this acts as an implicit argument to all the member functions.'\n\n",
            "Mole: 'Oh yes! Now before we let you go, we must warn you. Where this boat stops, a maze starts. Remember everything we have taught you and solve the questions to the best of your ability.'"
        };
        cout << messages[ind % 7] << "\n";
    }
    void turtle(int ind) 
    {
        string messages[] = 
        {
            "Turtle: 'Mhm! the member functions have some special characteristics that are often used in the program development. Like:\n 1] Several different classes can be use the same function name. The 'membership label' will resolve their scope.\n 2] Member functions can access the private data of the class. A nonmember function cannot do so.\n 3] A member function can call another member function directly,without using the dot operator.'\n\n", 
            "Turtle: 'It is possible to take the address of a member of a class and assign it to a pointer. The address of a member can be obtained by applying the operator & to a 'full qualified' class member name. A class member pointer can be declared using the operator ::* with the class name.'", 
            "Turtle: 'We can overload almost all the C++ operators except - class member access operators (.,.*), scope resolution operator (::), size operator (sizeof), conditional operator (?;)'", 
            "Turtle: 'The mechanism of deriving a new class from an old class is called inheritance. Inheritance provides the concept of reusability. The C++ classes can be reused using inheritance.'",
            "Turtle: 'However! they can access the private data through the member functions of the base class. Multipath inheritance may lead to duplication of inherited members from a grandparent base class. This may be avoided by making the common base class a virtual class.'",
            "Turtle: 'Polymorphism means 'one name, multiple forms'. It can be broadly classified into two catgeories: Compile time polymorphism and Run time polymorphism. Compile time polymorphism simply means that an object is bound to its function call at the compile time. ",
            "Turtle: 'All the best to you little lady! We hope you find your way out!' "          
        };
        cout << messages[ind % 7] << "\n";
    }
};
class maze
{
    private:
    int complexity;
    int exit;
    int counter;
public:
    class question {
    public:
        string q;
        string opt[4];
        char correct;
        question() {}
        question(string p, string o1, string o2, string o3, string o4, char ca) {
            q = p;
            opt[0] = o1;
            opt[1] = o2;
            opt[2] = o3;
            opt[3] = o4;
            correct = ca;
        }
    };
    question questions[20];
    maze() : complexity(1), exit(20), counter(0) {
        questions[0] = question("1. Alice, if a variable is declared inside a block, what is its scope?", "A) The entire program", "B) Until the end of that block", "C) Until the end of the function", "D) Until the program terminates", 'B');
        questions[1] = question("2. Alice, which operator in C++ allows access to a global variable when a local variable has the same name?", "A) . (Dot operator)", "B) -> (Arrow operator)", "C) :: (Scope resolution operator)", "D) : (Colon operator)", 'C');
        questions[2] = question("3. Alice, where can member functions be defined?", "A) Inside or outside the class definition", "B) Only inside the class definition", "C) Only outside the class definition", "D) Only in the main function", 'A');
        questions[3] = question("4. Alice, which of the following is NOT true about friend functions?", "A) A friend function is not in the scope of the class it is declared in", "B) A friend function can access private members of a class", "C) A friend function can be declared in either public or private section", "D) A friend function can be called using the object of the class", 'D');
        questions[4] = question("5. Alice, which type of data access allows child classes to access data but prevents access from outside the class?", "A) Private", "B) Public", "C) Protected", "D) Friend", 'C');
        questions[5] = question("6. Alice, what is the purpose of a constructor in C++?", "A) To destroy objects", "B) To allocate memory dynamically", "C) To initialize an object when it is created", "D) To copy one object into another", 'C');
        questions[6] = question("7. Alice, when is a copy constructor called?", "A) When an object is created and initialized at the same time", "B) When an object is deleted", "C) When a private member function is accessed", "D) When a function is overloaded", 'A');
        questions[7] = question("8. Alice, what is the purpose of operator overloading in C++?", "A) To automatically convert data types", "B) To enhance the flexibility of operators for user-defined data types", "C) To create new operators in C++", "D) To restrict the use of certain operators", 'B');
        questions[8] = question("9. Alice, which of the following operators cannot be overloaded?", "A) + (Addition)", "B) = (Assignment)", "C) ++ (Increment)", "D) :: (Scope resolution)", 'D');
        questions[9] = question("10. Alice, which of the following statements about operator functions is true?", "A) Operator functions must have at least one operand of a user-defined type", "B) Operator functions must always be static", "C) Operator functions cannot be member functions", "D) All operator functions must return an integer", 'A');
        questions[10] = question("11. Alice, what is multiple inheritance in C++?", "A) A derived class inheriting from only one base class", "B) A derived class inheriting from more than one base class", "C) A base class inheriting from a derived class", "D) A class containing objects of other classes", 'B');
        questions[11] = question("12. Alice, what is hierarchical inheritance?", "A) A class being derived from another derived class", "B) A class inheriting from multiple base classes", "C) One base class being inherited by multiple derived classes", "D) A base class containing objects of another class", 'C');
        questions[12] = question("13. Alice, what problem can occur in multipath inheritance, and how can it be avoided?", "A) The base class cannot be accessed; solved using friend functions", "B) The derived class cannot access private data; solved using protected members", "C) Duplication of inherited members; solved by making the common base class virtual", "D) Constructors execute in reverse order; solved by reordering the class declaration", 'C');
        questions[13] = question("14. Alice, if a class is inherited privately in C++, how does it affect the access specifiers of the base class members in the derived class?", "A) Public and protected members of the base class become private in the derived class", "B) Public members remain public, protected members become private", "C) Protected members remain protected, public members become protected", "D) All members remain unchanged in the derived class", 'A');
        questions[14] = question("15. Alice, what is an object pointer used for in C++?", "A) To create objects at runtime and access their public members", "B) To make a copy of an object", "C) To delete objects automatically when they are not needed", "D) To convert an object into a different data type", 'A');
        questions[15] = question("16. Alice, which operator is used to access members of an object when using a pointer?", "A) Dot operator (.)", "B) Scope resolution operator (::)", "C) Arrow operator (->)", "D) Asterisk operator (*)", 'C');
        questions[16] = question("17. Alice, what does the this pointer represent in C++?", "A) The base class of an object", "B)A pointer that always points to the first object in memory", "C) A pointer used for dynamic memory allocation", "D) A pointer that represents the object invoking a member function", 'D');
        questions[17] = question("18. Alice, what does polymorphism mean in C++?", "A) One function can have only one name", "B) One name, multiple forms", "C) Functions cannot be overloaded", "D) Objects cannot be inherited", 'B');
        questions[18] = question("19. Alice, what is another name for compile-time polymorphism?", "A) Early binding", "B) Late binding", "C) Dynamic linking", "D) Virtual function binding", 'A');
        questions[19] = question("20. Alice, which type of polymorphism determines the function call during program execution?", "A) Compile-time polymorphism", "B) Static linking", "C) Function overloading", "D) Run-time polymorphism", 'D');
    }
    void ask() {
        if (exit <= 0) 
        {
            cout << "Congratulations! Alice, you have escaped the maze!" << endl;
            return;
        }
        if (counter >= 20) 
        {
            cout << "You have answered all the questions! You have escaped the maze!" << endl;
            return;
        }
        char answer;
        while (true) 
        { 
            cout << "Question: " << questions[counter].q << endl;
            for (int j = 0; j < 4; j++) {
                cout << questions[counter].opt[j] << endl;
            }
            cout << "Answer (A/B/C/D): ";
            cin >> answer;
            answer = toupper(answer);
            
            if (answer == questions[counter].correct) 
            {
                exit--; 
                cout << "Correct! You move one step closer to the exit. Steps remaining: " << exit << "\n";
                break; 
            } 
            else 
            {
                complexity++; 
                cout << "Wrong answer! The maze becomes more complex. Complexity level: " << complexity << "\nTry again.\n";
            }
        }
        counter++;
    }
    int getexit() {
        return exit;
    }
};
class madhatter
{
    string que[17];
    char ans[17];
    char input;
    int check=0;
    public:
    madhatter ()
    {
        que[0]="#include <iostream.h>\nvoid main()\n{\n short i = 2500, j = 3000;\ncout >> \"i + j = \" >> -(i + j);\n}\nWhat are the errors in this code?\nA) #include <iostream.h> should be #include <iostream>\nB) void main() should be int main()\nC) cout >> should be cout <<\nD) All of the above\n";
        ans[0]='D';
        que[1]= "#include <iostream>\nint main()\n{\nint i = 5;\nwhile (i)\n{\n\tswitch (i)\n\t{\n\tdefault:\n\tcase 4:\n\tcase 5:\n\tbreak;\n\tcase 1:\n\tcontinue;\n\tcase 2:\n\tcase 3:\n\tbreak;\n\t}\n--;\n}\n}\nA) The continue; statement inside switch is invalid\nB) switch cannot be inside a while loop\nC) The program will cause an infinite loop\nD) #include <iostream> should be #include <iostream.h>\n";
        ans[1]='A';
        que[2]= "#include <iostream.h>\nvoid main()\n{\nint i = 10, j = 5;\nint modResult = 0;\nint divResult = 0;\nmodResult = i % j;\ncout << modResult << " ";\ndivResult = i / modResult;\ncout << divResult;\n}\nWhat will happen when this code is executed?\nA) It will compile and run successfully, outputting 0 and 10.\nB) It will cause a runtime error due to division by zero.\nC) #include <iostream.h> should be replaced with #include <iostream>.\nD) Both B and C.\n";
        ans[2]='D';
        que[3]= "#include <iostream>\n#define pi 3.14\nint squareArea(int &);\nint circleArea(int &);\nint main()\n{\nint a = 10;\nstd::cout << squareArea(a) << " ";\nstd::cout << circleArea(a) << " ";\nstd::cout << a << std::endl;\nreturn 0;\n}\nint squareArea(int &a)\n{\nreturn a *= a;\n}\nint circleArea(int &r)\n{\nreturn r = pi * r * r;\n}\nA) pi is defined as #define pi 3.14, which causes implicit type conversion to int\nB) The squareArea function modifies a, which may cause unintended behavior\nC) return a *= a; is invalid syntax\nD) cout << should be cout >>\n";
        ans[3]='A';
        que[4]="#include <iostream>\nvoid display(const int const1 = 5)\n{\nconst int const2 = 5;\nint array1[const1];\nint array2[const2];\nfor (int i = 0; i < 5; i++)\n{\narray1[i] = i;\narray2[i] = 10;\nstd::cout << array1[i] << " " << array2[i] << " ";\n}\n}\nint main()\n{\ndisplay(5);\nreturn 0;\n}\nA) const int const1 = 5; inside display is invalid because default parameters cannot be constant\nB) Variable-length arrays (array1[const1]) are not allowed in standard C++\nC) std::cout should be cout without std::\nD) The display(5); function call is incorrect\n";
        ans[4]='B';
        que[5]="#include <iostream>\nint gValue = 10;\nvoid extra()\n{\nstd::cout << gValue << " ";\n}\nint main()\n{\nextra();\n{\nint gValue = 20;\nstd::cout << gValue << " ";\nstd::cout << ::gValue << " ";\n}\nreturn 0;\n}\nA) ::gValue cannot be accessed inside a nested block\nB) The program does not compile because gValue is redefined in a nested block\nC) The extra() function should take gValue as a parameter instead of using the global variable\nD) There is no error; the program will execute successfully\n";
        ans[5]='A';
        que[6]="#include <iostream>\nint fun()\n{\nreturn 1;\n}\nfloat fun()\n{\nreturn 10.23;\n}\nint main()\n{\nstd::cout << (int)fun() << ' ';\nstd::cout << (float)fun() << ' ';\nreturn 0;\n}\nA)The program should use printf() instead of cout\nB) The typecasting of fun() is incorrect\nC)Function overloading cannot be done with only return type differences\nD) The main() function should not return 0\n";
        ans[6]='C';
        que[7]="#include <iostream>\nclass Room;\nvoid Area()\n{\nint width, height;\nclass Room\n{\nint width, height;\npublic:\nvoid setValue(int w, int h)\n{\nwidth = w;\nheight = h;\n}\nvoid displayValues()\n{\nstd::cout << (float)width << ' ' << (float)height;\n}\n};\nRoom objRoom1;\nobjRoom1.setValue(12, 8);\nobjRoom1.displayValues();\n}\nint main()\n{\nArea();\nRoom objRoom2;\nreturn 0;\n}\nA) The class Room is defined inside Area(), making it inaccessible in main()\nB) cout should be replaced with printf() for float formatting\nC) The program is missing a using namespace std; statement\nD) The class Room should be declared as static inside Area()";
        ans[7]='A';
        que[8]="#include <iostream>\nclass Room;\nvoid Area()\n{\nint width, height;\nclass Room\n{\nint width, height;\npublic:\nvoid setValue(int w, int h)\n{\nwidth = w;\nheight = h;\n}\nvoid displayValues()\n{\nstd::cout << (float)width << ' ' << (float)height;\n}\n};\nRoom objRoom1;\nobjRoom1.setValue(12, 8);\nobjRoom1.displayValues();\n}\nint main()\n{\nArea();\nRoom objRoom2;\nreturn 0;\n}\nA)cout should be replaced with printf() for performance reasons\nB) The static variable count should be initialized inside the constructor\nC) displayCount() should be declared as static\nD)setCount() is a static function and should not take any parameters";
        ans[8]='D';
        que[9]="#include <iostream>\n\nclass Room\n{\n    int width;\nint height;\nstatic int copyConsCount;\n\npublic:\nRoom()\n{\nwidth = 12;\nheight = 8;\n}\n\nRoom(const Room& r)\n{\nwidth = r.width;\nheight = r.height;\n copyConsCount++;\n}\n\nvoid dispCopyConsCount()\n{\nstd::cout << copyConsCount;\n}\n};\n\nint Room::copyConsCount = 0;\n\nint main()\n{\n    Room objRoom1;\nRoom objRoom2(objRoom1);\nRoom objRoom3 = objRoom1;\nRoom objRoom4;\nobjRoom4 = objRoom3;\n\nobjRoom1.dispCopyConsCount();\n return 0;\n}\nA) The copy constructor is incorrectly declared and should not be const\nB) The assignment objRoom4 = objRoom3; does not invoke the copy constructor\nC) The static variable copyConsCount should be initialized inside the constructor\nD) dispCopyConsCount() should be declared as static";
        ans[9]='B';
        que[10]="#include<iostream>\nclass Room\n{\nint length;\nint width;\npublic:\nRoom(int l,int w=0):width(w),length(l)\n{\n}\n};\nint main()\n{\nRoom objRoom1;\nRoom objRoom2(12,8);\nreturn 0;\n}\nA) The class Room is missing a default constructor\nB) The order of initialization in Room(int l, int w = 0) : width(w), length(l) is incorrect\nC) width should not have a default value\nD) The constructor should be defined outside the class";
        ans[10]='A';
        que[11]="#include<iostream>\nclass Space\n{\nint mCount;\npublic:\nSpace():mCount(0){}\nSpace(int count):mCount(count){}\nSpace operator++()\n{\nmCount++;\nreturn Space(mCount);\n}\n};\nint main()\n{\nSpace objSpace;\nobjSpace++;\nreturn 0;\n}\nA) The class Space is missing a constructor that takes an integer\nB) The operator++() function should return a reference instead of an object\nC) The code is missing an overload for the post-increment operator (operator++(int))\nD) mCount should be a static variable";
        ans[11]='C';
        que[12]="#include<iostream>\nclass Room\n{\nfloat mWidth;\nfloat mLength;\npublic:\nRoom():mWidth(0),mLength(0){}\nRoom(float w,float h):mWidth(w),mLength(h){}\noperator float()\n{\nreturn mWidth*mLength;\n}\nfloat getWidth(){return mWidth;}\nfloat getLength(){return mLength;}\n};\nint main()\n{\nRoom objRoom(2.5,2.5);\nfloat fTotalArea;\nfTotalArea=objRoom;\ncout<<fTotalArea;\nreturn 0;\n}\nA) The class Room should not have an implicit conversion operator\nB) The default constructor should initialize member variables\nC) cout is undefined because std:: is missing\nD) The operator float() should return an integer value";
        ans[12]='C';
        que[13]="#include<iostream>\nclass A\n{\nint i;\n};\nclass AB:virtual public A\n{\nint j;\n};\nclass ABAC;\nclass AC:public A,public AB\n{\nint k;\n};\nclass ABAC:public AB,public AC\n{\nint l;\n};\nint main()\n{\nABAC abac;\nstd::cout<<\"sizeof ABAC:\"<<sizeof(abac);\nreturn 0;\n}\nA) The class ABAC is used before being defined\nB) The class A should have a virtual destructor\nC) Multiple inheritance is not allowed in C++\nD) The sizeof(abac) statement is incorrect";
        ans[13]='A';
        que[14]="#include<iostream>\nclass B1\n{\nint b1=10;\npublic:\nvoid display()\n{\nstd::cout<<b1<<\"\\n\";\n}\n};\nclass B2\n{\nint b2=20;\npublic:\nvoid display()\n{\nstd::cout<<b2<<\"\\n\";\n}\n};\nclass D:public B1,public B2\n{\n};\nint main()\n{\nD d;\nd.B1::display();\nd.B2::display();\nreturn 0;\n}\nA) The function display() in class D should be explicitly defined\nB) The call d.display(); is ambiguous due to multiple inheritance\nC) The base classes should be declared as virtual to avoid ambiguity\nD) The class D must explicitly call base class constructors";
        ans[14]='B';
        que[15]="#include<iostream>\nclass Person\n{\nint age;\npublic:\nPerson():age(0){}\nPerson(int age)\n{\nthis.age=age;\n}\nPerson& operator<(Person& p)\n{\nreturn age<p.age?p:*this;\n}\nint getAge()\n{\nreturn age;\n}\n};\nint main()\n{\nPerson p1(15);\nPerson p2(11);\nPerson p3;\np3=p1<p2;\nstd::cout<<p3.getAge();\nreturn 0;\n}\nA) this is not a normal variable and should use this->age instead of this.age\nB) The < operator must return a boolean value (true or false)\nC) The operator< should be declared const\nD) The default constructor must explicitly initialize age";
        ans[15]='A';
        que[16]="#include<iostream>\nusing namespace std;\nclass Base\n{\npublic:\nvirtual void show()=0;\n};\nclass Derived: public Base\n{\npublic:\nvoid show()\n{\ncout<<\"Derived class show()\"<<\"\\n\";\n}\n};\nint main()\n{\nDerived d;\nd.show();\nreturn 0;\n}\nA) The program will not compile as Base has a pure virtual function\nB) The program will give a linker error due to an unresolved reference\nC) The program will compile and run, displaying \"Derived class show()\"\nD) The function show() in Derived must be explicitly marked as override";
       ans[16]='C';

    }
    void read()
    {
        cout<<"Answer (A/B/C/D): ";
        cin>>input;
        input=toupper(input);
    }
    bool evaluate(int i)
    {
        check++;
            if (input==ans[i])
            {
                cout<<"Pass"<<endl;
                return true;
            }
            else
            {
                string sass[] =
                {
                    "Oh honey, that was a bold choice, but still wrong. Try again! Perhaps with a bit more sanity?",
                    "Are you trying to make the compiler cry, or are we simply embracing the chaos today?",
                    "Even the Mad Hatter is confused by that answer—and trust me, thats an achievement!",
                    "Are you sure about that? Or are you just playing a very risky game of make-believe?",
                    "That answer was so wrong, even the Cheshire Cat disappeared out of embarrassment.",
                    "Oops! That answer belongs in the Queen of Hearts dungeon—off with its head!",
                    "404: Correct answer not found. But do check Wonderlands lost-and-found!",
                    "That was… a fascinating work of fiction. But no, try again!",
                    "If answers were tea, yours would have just spilled all over the table.",
                    "Oh, dear! That answer just fell down the rabbit hole—never to be seen again!",
                    "You must be late for a very important fact-checking session, because that was NOT it!",
                    "That answer is curiouser and curiouser… yet somehow still terribly wrong!",
                    "I admire the confidence! The accuracy? Not even the White Rabbit could find it.",
                    "If wrong answers earned XP, youd be the Mad Hatters grandmaster of nonsense by now!",
                    "Your logic just took a detour… straight into Wonderlands most puzzling paradox.",
                    "Id say close, but then Id be stretching reality thinner than the March Hares patience."
                };
                cout<<sass[i]<<endl;
                return false;
            }
    }
    void challenge()
    {
        for (int i=0;i<17;i++)
        {
            cout<<"Question: "<<i+1 <<endl<<que[i]<<endl;
            do
            {
                read();
                if (input!='A' && input!='B' && input!='C' && input!='D')
                {
                    cout <<"Invalid answer. Please choose A, B, C, or D."<<endl;
                }
            } while ((input!='A' && input!='B' && input!='C' && input!='D') || !evaluate(i));
            cout<<endl;
        }
        cout<<"Your score is: "<<check<<"/16";
    }
};
class Queen 
{
public:
    
    void fight() 
    {
        cout << "\nQueen: First, let's talk about necessity. Why OOP, you ask? Because without it, the world would be a chaotic mess of unstructured code!" << endl;
        cout << "Alice: Kinda like your kingdom? Sounds about right." << endl;
        cout << "Queen: Insolent! My kingdom is perfectly structured, unlike procedural programming!" << endl;
        cout << "Queen: Now, Data Hiding! You don't just let anyone peek into your royal affairs, do you? NO!" << endl;
        cout << "Alice: I dunno, sounds like you have plenty to hide." << endl;
        cout << "Queen: It's called protecting vital information from meddling fools!" << endl;
        cout << "Queen: Abstraction? Only show what is necessary!" << endl;
        cout << "Alice: Like how you only show your nice side when you need something?" << endl;
        cout << "Queen: Hah! Unlike you, I understand when to reveal and when to conceal!" << endl;
        cout << "Queen: Encapsulation is keeping things bundled together—like my royal decrees and my absolute authority!" << endl;
        cout << "Alice: So you're saying you keep all your bad decisions in one place? Makes sense." << endl;
        cout << "Queen: Watch your tongue, girl, or you'll see just how securely I can encapsulate you in my dungeons!" << endl;
        cout << "Queen: Procedural Abstraction means my subjects don't need to know how my court functions—only that it does!" << endl;
        cout << "Alice: Wow, sounds like a dictatorship. Maybe inheritance would help distribute some power?" << endl;
        cout << "Queen: Hah! Inheritance only passes power to the worthy, and NONE are worthy of MY throne!" << endl;
        cout << "Queen: And then, of course, we have Classes and Objects. A class is like a blueprint of perfection, much like myself!" << endl;
        cout << "Alice: If that's the case, I'd rather use a different object." << endl;
        cout << "Queen: How dare you! There is no greater instance than ME!" << endl;
        cout << "Queen: And objects? They are instances of that perfection, but none can truly compare to the original—ME!" << endl;
        cout << "Alice: Sure, if by 'original' you mean the buggiest prototype." << endl;
        cout << "Queen: Enough! Be gone, before I override your existence!" << endl;
        cout << "Alice: Oh, don't worry, I'm done wasting memory on this conversation." << endl;
        spells();
    }
private:
    class Question 
    {
    public:
        string q;
        string opt[4];
        char correct;
        Question() {}
        Question(string p, string o1, string o2, string o3, string o4, char ca) 
        {
            q = p;
            opt[0] = o1;
            opt[1] = o2;
            opt[2] = o3;
            opt[3] = o4;
            correct = ca;
        }
    };
    Question questions[15];
    int counter;
    int health;
public:
    Queen() : counter(0), health(5) 
    { 
        questions[0] = Question("What will be the output of the following C++ program?\n#include <iostream>\nusing namespace std;\nint x = 10;\nvoid func() {\nint x = x + 5;\ncout << x << endl;\n}\nint main()\n{\nfunc();\nreturn 0;\n}", "A) 10", "B) 15", "C) Compilation error", "D) Garbage value", 'C');
        questions[1] = Question("What will be the output of this code?\n#include <iostream>\nusing namespace std;\nclass Base {\npublic:\nvoid display() { cout << 'Base Class' << endl; }\n};class Derived : public Base {\npublic:\nvoid display(int x) { cout << 'Derived Class' << endl; }\n};\nint main() {\nDerived obj;\nobj.display();\nreturn 0;\n}", "A) Base Class", "B) Derived Class", "C) Compilation error", "D) Undefined behavior", 'C');
        questions[2] = Question("What is the output of the following C++ code?\n#include <iostream>\nusing namespace std;\nclass Test {\npublic:\nint x = 5;\nvoid show() { cout << \"Value of x: \" << x << endl; }\n};\nint main() {\nTest *ptr = NULL;\nptr->show();\nreturn 0;\n}", "A) Value of x: 5", "B) Segmentation fault", "C) Garbage value output", "D) Compilation error", 'B');
        questions[3] = Question("How many times is the copy constructor called in this program?\n#include <iostream>\nusing namespace std;\nclass A {\npublic:\nA() { cout << \"Constructor\" << endl; }\nA(const A& obj) { cout << \"Copy Constructor\" << endl; }\n};\nvoid func(A obj) { }\nint main() {\nA a1;\nA a2 = a1;\nfunc(a2);\nreturn 0;\n}", "A) 0", "B) 1", "C) 3", "D) 2", 'D');
        questions[4] = Question("What happens if you try to delete the same dynamically allocated pointer twice?", "A) Memory leak", "B) Segmentation fault", "C) Compiler error", "D) Undefined behavior", 'D');
        questions[5] = Question("cout << add(3.5, 2);\nWhich of the following overloaded function prototypes can handle this call?", "A) int add(int a, int b, int c);", "B) double add(double x, double y);", "C) double add(int p, double q);", "D) Compilation error", 'D');
        questions[6] = Question("#include <iostream>\nclass Room\n{\nint width;\nint height;\nstatic int copyConsCount;\npublic:\nRoom() { width = 12; height = 8; }\nRoom(const Room& r) { width = r.width; height = r.height; copyConsCount++; }\nvoid dispCopyConsCount() { std::cout << copyConsCount; }\n};\nint Room::copyConsCount = 0;\nint main() {\nRoom objRoom1;\nRoom objRoom2(objRoom1);\nRoom objRoom3 = objRoom1;\nRoom objRoom4;\nobjRoom4 = objRoom3;\nobjRoom1.dispCopyConsCount();\nreturn 0;\n}", "A) The copy constructor is incorrectly declared and should not be const", "B) The assignment objRoom4 = objRoom3; does not invoke the copy constructor", "C) The static variable copyConsCount should be initialized inside the constructor", "D) dispCopyConsCount() should be declared as static", 'B');
        questions[7] = Question("What will be the output of this code?\n#include <iostream>\nusing namespace std;\nclass Test {\npublic:\nvoid show() {\ncout << 'Address of current object:' << this << endl;\n}\n};\nint main() {\nTest obj1, obj2;\nobj1.show();\nobj2.show();\nreturn 0;\n}", "A) Same address printed twice", "B) Compilation error", "C) Different addresses printed", "D) Undefined behavior", 'C');
        questions[8] = Question("What is the correct way to access a global variable inside a function?", "A) ::varname", "B) global.varname", "C) this->varname", "D) #define GLOBAL varname", 'A');
        questions[9] = Question("What happens if 'new' fails?", "A) It returns NULL", "B) The compiler generates a warning", "C) It terminates the program immediately", "D) It throws a bad_alloc exception", 'D');
        questions[10] = Question("Which of the following is incorrect for operator overloading?", "A) sizeof and ?: can be overloaded.", "B) Overloading cannot change the precedence of operators.", "C) Overloading cannot change its associativity.", "D) At least one operand must be of a user-defined type.", 'A');
        questions[11] = Question("Room objRoom(2.5, 2.5);\nfloat fTotalArea;\nfTotalArea = objRoom;\ncout << fTotalArea;", "A) The class Room should not have an implicit conversion operator", "B) The default constructor should initialize member variables", "C) cout is undefined because std:: is missing", "D) The operator float() should return an integer value", 'C');
        questions[12] = Question("What will be the output of the following C++ program?\n#include <iostream>\nusing namespace std;\nclass A {\npublic:\nvoid show() { cout << 'Class A' << endl; }\n};\nclass B : virtual public A {};\nclass C : virtual public A {};\nclass D : public B, public C {};\nint main() {\nD obj;\nobj.show();\nreturn 0;\n}", "A) Compilation error", "B) Class A", "C) Ambiguous function call", "D) Ambiguous function call", 'B');
        questions[13] = Question("What will happen in the following code?\n#include <iostream>\n#include <memory>\nusing namespace std;\nclass Test {\npublic:\nTest() { cout << \"Constructor called\" << endl; }\n~Test() { cout << \"Destructor called\" << endl; }\n};\nint main() {\nshared_ptr<Test> ptr1 = make_shared<Test>();\nshared_ptr<Test> ptr2 = ptr1;\nweak_ptr<Test> ptr3 = ptr1;\ncout << ptr1.use_count() << endl;\nptr2.reset();\ncout << ptr1.use_count() << endl;\nreturn 0;\n}", "A) 1 1", "B) 2 0", "C) Undefined behavior", "D) 2 1", 'D');
        questions[14] = Question("What will be the output of the following?\n#include<iostream>\nusing namespace std;\nclass Room\n{\nfloat mWidth;\nfloat mLength;\npublic:\nRoom():mWidth(0),mLength(0){}\nRoom(float w,float h):mWidth(w),mLength(h){}\noperator float()\n{\nreturn mWidth*mLength;\n}\nfloat getWidth(){return mWidth;}\nfloat getLength(){return mLength;}\n};\nint main()\n{\nRoom objRoom(2.5,2.5);\nfloat fTotalArea;\nfTotalArea=objRoom;\ncout<<fTotalArea;\nreturn 0;\n}", "A) The class Room should not have an implicit conversion operator", "B) The default constructor should initialize member variables", "C) cout is undefined because std:: is missing", "D) The operator float() should return an integer value", 'C');

    }
    void spells() 
    {
        cout << "\nQueen: You insolent little WITCH! I'll teach you a lesson" << endl;
        char answer;
        while (health > 0 && counter < 15) 
        {
            cout << "\n Queen casts a spell! " << endl;
            cout << questions[counter].q << endl;
            for (int j = 0; j < 4; j++) 
            {
                cout << questions[counter].opt[j] << endl;
            }
            cout << "Answer (A/B/C/D): ";
            cin >> answer;
            if (cin.fail())  
            {
                cin.clear();              
                cin.ignore(1000, '\n');   
                cout << "Invalid input! Try again." << endl;
            } 
            else 
            {
                answer = toupper(answer);
                if (answer == questions[counter].correct) 
                {
                    cout << "Alice dodges the spell! " << endl;
                    counter++;
                } 
                else 
                {
                    health--;
                    cout << " Alice gets hit! HP left: " << health <<endl;
                }
            }
        }
        if (health == 0) 
        {
            cout << "\n Alice has been defeated! The Queen laughs victoriously." << endl;
        } 
        else 
        {
            cout << "\n Alice wins! The Queen is defeated!" << endl;
        }
    }
};
class Alice : public hall_of_knowledge , public Animal , public maze , public madhatter , public Queen
{
    public:
    void first()
    {
        cout<<"Alice followed the rabbit into the rabbit hole and tumbled into a seemingly endless fall. The air rushed past her as she spiraled downward, her surroundings shifting in eerie slow motion. Strange symbols and words flickered across the walls of the tunnel, glowing faintly as if whispering secrets only she could see."<<endl;
        for (int i=0;i<8;i++)
            {
                rabbit_hole();
            }
        cout<<"Hello Alice!!\nWelcome to the Hall Of Knowdledge."<<endl;
        cout<<"To exit this level you must open all the doors and read and understand the Knowledge provieded behind each door. Then answer the Quiz provieded at the last door to exit."<<endl;
        for (int i=0;i<5;i++)
        {
            open_door();
        }
        cout<<"The Quiz begins.\n All The Best!!"<<endl;
    }
    void sec()
    {
        cout << "Alice busts out the final door in the Hall of Knowledge. She runs as quickly as she can, desperate to get away from that Hall she encountered. As she runs, she spots the White Rabbit. Aha! This was the Rabbit that led her here. And she was determined to make him pay. She runs faster, calling out to the White Rabbit. The Rabbit, indifferent to Alice calling him, untied the knot that held the boat to shore and jumped in. The Rabbit sails away just as Alice reaches the shore. She was about to lose all hope when she spotted another boat. Alice brightened up and quickly untied the knot holding this boat to the shore. She sets sail, right behind the Rabbit, determined to get to him. As her boat moves with waves leading her closer to the Rabbit, a Mole pops his little head out. Alice is surprised to see him. 'Hello there!', the Mole waves to her with a smile. Before she can recover, an Owl, a Fish and a Turtle join them. 'Hey!', the others wave to her.\n\n";
    }
    void third()
    {
        cout << "\n\n\n The animals quickly leave Alice's side as she approaches the island. She was so caught up with their talking, she forgot about the White Rabbit! Nonetheless, as she ties the boat to shore, she tries to recall everything the animals taught her. After all, they did warn her about a maze. She wonders what it was all about. Just as Alice begins to walk onto the island, she spots the Rabbit again! She breaks into a sprint, chasing behind the Rabbit. But as always, the Rabbit was too quick for her. She chased him through the highs and lows of the jungle until she managed to reach a maze. She tried to follow the Rabbit in, but she quickly lost sight of him. Alice suddenly remembers the warning of the animals....This was the maze they were talking about! With newfound determination, Alice steps forward. She was going to make her way out of this\n\n." << endl;
    }
    void forth()
    {
        cout << "\"Hello and Welcome to the tea bugging party!!\" says The Madhatter." << endl;
        cout<<"To drink the tea, debug the question provided to you when you pour in the tea."<<endl;
        cout << "From the other end of the table, rabbits say to Alice that, \"each wrong answer while debugging would lead to the Madhatter scolding her.\"" << endl;
    }
    void fifth() 
    {
        cout << "Queen: Well, well, well. Look who it is! Another clueless little girl in MY domain." << endl;
        cout << "Alice: Oh great, another self-important ruler who thinks they own the place." << endl;
        cout << "Queen: You dare to stand before me without understanding the very fabric of the world you exist in?" << endl;
        cout << "Queen: Hmph! Let me see if you have even a clue about Object-Oriented Programming!" << endl;
        cout << "Alice: I do understand OOP, thank you very much. But sure, go on with your royal nonsense." << endl;
    }
};
int main()
{
   Alice A,B,C,D,E,F,G,H,I,J;
   //INTRO FN
   A.first();
   //hall of knowledge
   B.hall_of_knowledge::question(); 
   //second stage
   C.sec();
    //animal
    int index = 0;
    for (int i = 0; i < 56; i++) 
    {
        int choice = i % 5; 
        switch (choice) 
        {
            case 0: 
                D.owl(index);
                break;
            case 1: 
                D.fish(index);
                break;
            case 2: 
                D.cat(index);
                break;
            case 3: 
                D.mole(index);
                break;
            case 4: 
                D.turtle(index);
                break;
        }
        index++;
    }
    //third stage
    E.third();
    //maze
    while (F.getexit() > 0) 
    {
        F.ask();
    }
    cout << "You have escaped the maze!" << endl;
    //forth stage
    G.forth();
    //madhatter
    H.challenge();
    //fith stage 
    I.fifth();
    //queen
    J.fight();
    return 0;
}
